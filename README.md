# lanter-film-search

Design
------

* I decided to build this API as a standalone Node/Express service, since this could allow an easy jumping-off point for further endpoints or more robust behavior in the future.
* Express was an obvious choice for quickly getting a basic server up and running. The built-in fetch function was perfectly sufficient for making API calls to the downstream services rather than bringing in an extra library. I did choose to use lodash specifically for the array deduplication method, since that kind of operation has the potential for being inefficient had I decided to reinvent the wheel instead of taking advantage of an existing method.
* The three downstream API request functions are only called if the corresponding exclude flags are not true, in which case they're replaced by an empty array, treating them as though no results were returned. I made the assumption that it was safe to use a string composed of the film title and year for deduplication, since films with identical titles can have been produced in different years. I decided to have the sorting default to title ascending, rather than returnining an array if those parameters are invalid, for a smoother user experience.

Pagination
----------
Guaranteeing correct pagination, given the specifications of this system, did seem like a significant problem to me. As an example, I imagined that a user requested `currentPage: 0` and `pageSize: 10`. In generating the response, the top 10 results by the specified sorting method (and therefore the entire page) were all from the VHS service, so the results pulled from the DVD and Projector services were all ignored and not sent back to the client. In this situation, if the user were to request `currentPage: 1`, the service should request `currentPage: 1` from the VHS service, and `currentPage: 0` from the DVD and Projector services, and aggregate the final result based on those responses. The only way for the service to know that this is the case is if it were to first generate the response for `currentPage: 0` before generating the response for `currentPage: 1`. Following this logic, if a user were to request `currentPage: 100`, the service would have to first determine pages 0-99, requiring up to 300 requests to the upstream services. To me, this would present an unacceptable amount of latency for the user. It could be mitigated through caching, but that would of course also present the possibility of stale data being presented to the user.

I've updated the code to reflect this solution, using a simple in-memory cache, which could easily be swapped out for a more robust solution like Redis, which would also provide expiration of cached values.

I saw two possible solutions to eliminating the pagination issue that were beyond the scope of this exercise. The first would be to combine all three services and store all different types of films in the same database. This would make pagination trivial, down to a simple query. The second solution, if it were necessary to keep them separate (or too complex to combine them), would be to use an event-based architecture to keep the front-facing aggregate service up-to-date with all necessary data stored in its own database. It could store only the fields necessary for searching and sorting, as well as unique ids for each record. This would allow a simple search with correct pagination to be done on the aggregate service's database, which could then make any necessary requests to the upstream services for extra data, using an array of ids to specify which records to retrieve.
